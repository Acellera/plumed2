// This document is formatted for Doxygen
/**

\page HowToPlumedYourMD How to add plumed to an MD code

Plumed ships with scripts that can be used to add it to many of the standard MD packages.  Obviously though, if no patch is provided for the MD code you use then you will have to write one yourself.  Plumed has been designed so that it can be added to an MD code either statically or as a dynamic library.  It is NOT possible to compile plumed as a static library and link the library.  Furthermore, unlike the previous version of plumed, the plumed source code is not compiled at the same time as your MD code is compiled.  Instead plumed now has its own makefile and is compiled separately to the MD engines that rely on it.  This makes plumed patches considerably simpler as now they only do two things:

- Modify the makefile so that the plumed is linked to the MD code
- Modify the source code to add all the required calls to plumed

\section makefile Modifying your makefile

Once the plumed source code has been compiled a file called src/Plumed.inc will be created.  This file must be included in your MD code's makefile as it informs the code where to find all the plumed source.  In particular, within the code the three variables described below are defined one of which must be added to the command that does the linking for your MD engine:  

- \$(PLUMED_OBJ) - This will statically link plumed to your MD engine
- \$(PLUMD_SHARED_OBJ) - This will dynamically bind plumed to your MD engine.  Furthermore, plumed will not run if you move the libplumedKernel.so library to a new location after compilation.
- \$(PLUMED_KERNEL) - This allows you to specify the location of plumed at runtime through the PLUMD_KERNEL environment variable.  Obviously, if at runtime this variable is not set, then none of plumed functionality will be available.

For consistency with the other plumed patches please ensure that your new patch allows users to compile with all three options.  Other users should be able to select which compilation mode they require using the following flags:

- --static for \$(PLUMED_OBJ)
- --shared for \$(PLUMED_SHARED_OBJ)
- --runtime for \$(PLUMED_WRAPPER)

\section language Language dependence

The interface between plumed and the MD codes is written is plain C so it is compatible with codes that are written in plain C, C++ and fortran.  This interface contains four routines:

- plumed_installed - This routine ensures that a version of plumed is available
- plumed_create - This routine creates the plumed object
- plumed_command - This routine passes some infomration to plumed or instructs plumed to perform some action
- plumed_finalize - This routine destroys the plumed objects

The first of these takes in an int*, which is set equal to 1 if a version of plumed is found.  The remaining three routines can be called in one of three ways.  In C++ codes you can either declare a PLMD::Plumed object from plumed or inherit the PLMD::Plumed class.  You can then call the methods of this class to do the above.  In this case the creation and desctruction of the plumed object is looked after and one need only use the cmd method (which is essentially a wrapper to plumed_cmd) to pass various pieces of data between you md code and plumed as described below.  For C and C++ codes one can also store the plumed object dynamically in which case these routines are called as:

- plumed_create() - which will return a pointer to plumed object that must be saved.
- plumed_cmd(plumed, const char*, const void* ) - here the first argument must be the pointer returned by plumed_create while the second and third describe are used to pass a pointer to some data in the code along with guidance as to what the data is.
- plumed_finalize(plumed) - here the argument is the pointer return by plumed_create.

while for fortran codes you must store the plumed pointer as a global object and use the global interface by calling:

- plumed_g_create()
- plumed_g_command(const char* ,const void* ) - Clearly the two arguments here are the second two arguments in plumed_cmd
- plumed_g_finalize()     

\section mdImplementation A practical example

We now describe how to pass data to plumed in from an MD code that is written in C/C++.  If your code is written in fortran follow the same procedure but use the global routines as described in the previous section.  In files containing calls to plumed you will have to include the Plumed.h file.  In addition, you will also have to define a plumed obect that is visible in all these routines and you will probably like to define some sort of plumedswitch, which can be read in from the input to your code and used to tell the code whether or not this is to be a run with plumed.  Finally, you might like to include something in input so that you specify the name of the plumed input file.  How these things are best done will depend on your code and so we leave it to your discretion.  

Plumed must perform three actions inside your MD code:

- It must be initialized before the main MD loop starts so that the plumed input files are read in.
- It must be called every MD step so that the forces from the bias can be computed.
- It must be finalized when the simulation is completed

The various calls that can be used during initialization are as follows:

\verbatim
plumed plumedmain; plumedmain=plumed_create();                 // Create the plumed object

// Calls to pass data to plumed
plumed_cmd(plumedmain,"setRealPrecision",&real_precision);     // Pass a pointer to the precision used in the code to plumed
plumed_cmd(plumedmain,"setKBoltzman",&kB);                     // Pass a pointer to the value of boltzmanns constant in this code (why?)
plumed_cmd(plumedmain,"setMDEnergyUnits",&energyUnits);        // Pass a pointer to the conversion factor between the energy unit used in your code and kJ mol-1
plumed_cmd(plumedmain,"setMDLengthUnits",&lengthUnits);        // Pass a pointer to the conversion factor between the length unit used in your code and nm 
plumed_cmd(plumedmain,"setMDTimeUnits",&timeUnits);            // Pass a pointer to the conversion factor between the time unit used in your code and fs?
plumed_cmd(plumedmain,"setPlumedDat",&plumedInput);            // Pass the name of the plumed input file from the md code to plumed
plumed_cmd(plumedmain,"setMPIComm",&MPI_COMM_WORLD);           // Pass a pointer to the MPI communicator to plumed?
plumed_cmd(plumedmain,"setNatoms",&natoms);                    // Pass a pointer to the number of atoms in the system to plumed
plumed_cmd(plumedmain,"setMDEngine","gromacs");                // Pass the name of your md engine to plumed
plumed_cmd(plumedmain,"setLog",fplog);                         // Pass the file on which to write out the plumed log 
plumed_cmd(plumedmain,"setLogFile",fplog);
plumed_cmd(plumedmain,"setTimestep",&delta_t);                 // Pass a pointer to the molecular dynamics timestep to plumed

// Calls to do the actual initialization (all the above commands must appear before this call)
plumed_cmd(plumedmain,"init",NULL);                            // Do all the initialization of plumed
plumed_cmd(plumedmain,"read",read);                            // Read the plumed input.  N.B. This is called during init and so this call is only required in special cases. 
\endverbatim

Please note that if your code is in fortran the mpi communicator should be passed using:

\verbatim
call plumed_g_cmd("setMPIFComm"//char(0),MPI_COMM_WORLD)
\endverbatim

The various calls that can be used pass data and calculate the forces due to the bias are as follows:

\verbatim
// Calls to pass data to plumed
plumed_cmd(plumedmain,"setStep",&step);                      // Pass a pointer to the current timestep to plumed
/ *** The way that you pass positions will depend on how they are stored in your code.  If the x, y and z position are all stored in a single array you may use:
plumed_cmd(plumedmain,"setPositions",&pos[0][0]);            // Pass a pointer to the first element in the atomic positions array to plumed  
/ *** Othersize if you pass the three separate vectors of x, y and z positions using:
plumed_cmd(plumedmain,"setPositionX",&x[0]);                 // Pass a pointer to the first element in the array of x component of the atomic positions to plumed
plumed_cmd(plumedmain,"setPositionY",&y[0]);                 // Pass a pointer to the first element in the array of y component of the atomic positions to plumed
plumed_cmd(plumedmain,"setPositionZ",&z[0]);                 // Pass a pointer to the first element in the array of z component of the atomic positions to plumed
plumed_cmd(plumedmain,"setMasses",&mass[0]);                 // Pass a pointer to the first element in the masses array to plumed
plumed_cmd(plumedmain,"setCharges",&charge[0]);              // Pass a pointer to the first element in the charges array to plumed
plumed_cmd(plumedmain,"setBox",&box[0][0]);                  // Pass a pointer to the first element in the box share array to plumed
plumed_cmd(plumedmain,"setEnergy",&poteng);                  // Pass a pointer to the current value of the potential energy to plumed?
/ *** The way that you pass forces will depend on how they are stored in your code.  If the x, y and z force are all stored in a single array you may use:
plumed_cmd(plumedmain,"setForces",&f[0][0]);                 // Pass a pointer to the first element in the foces array to plumed
/ *** Othersize if you pass the three separate vectors of x, y and z forces using:
plumed_cmd(plumedmain,"setForcesX",&fx[0]);                  // Pass a pointer to the first element in the array of the x components of the atomic forces to plumed
plumed_cmd(plumedmain,"setForcesY",&fy[0]);                  // Pass a pointer to the first element in the array of the y components of the atomic forces to plumed
plumed_cmd(plumedmain,"setForcesZ",&fz[0]);                  // Pass a pointer to the first element in the array of the z components of the atomic forces to plumed
plumed_cmd(plumedmain,"setVirial",&force_vir[0][0]);         // Pass a pointer to the first element in the virial array to plumed

// Calls to do actual calculations
plumed_cmd(plumedmain,"calc",NULL);                          // Calculate and apply forces from the biases defined in the plumed input
// In some cases it can be faster to break up the above command into its individual setps:
plumed_cmd(plumedmain,"prepareCalc",NULL);                   // Prepare to do a calculation by requesting all the atomic positions from the MD code
plumed_cmd(plumedmain,"prepareDependencies",NULL);           // Work out what we are calculating during this MD step (this is the first step of prepareCalc)
plumed_cmd(plumedmain,"shareData",NULL);                     // Request all the atomic positions from the MD code (this is the second step of prepareCalc)
plumed_cmd(plumedmain,"performCalc",NULL);                   // Use the atomic positions collected during prepareCalc phase to calculate colvars and biases.

// Some extra calls that might come in handy
plumed_cmd(plumedmain,"createFullList",&n);                  // Create a list containing of all the atoms plumed is using to do calculations (return the number of atoms in n)
plumed_cmd(plumedmain,"getFullList",&list);                  // Return a list (in list) containing all the indices plumed is using to do calculations
plumed_cmd(plumedmain,"clearFullList",NULL);                 // Clear the list of all the atoms that plumed is using to do calculations
plumed_cmd(plumedmain,"clear",clear);                        // Clear and delete all the pointers inside plumed.
\endverbatim

The plumed calls for the finalization tasks is as follows:

\verbatim
plumed_finalize(plumedmain);          // Call the plumed destructor
\endverbatim

\section mpicodes Dealing with parallelism

Plumed has functionality to deal with parallel MD codes.  The particular form of the functionality used to do this (and the frequency with which you will have to call these routines) will depend on whether your code is parallelism using a domain decomposition or particle decomposition strategy.  The calls for required for using this functionality are as follows:

\verbatim
plumed_cmd(plumedmain,"setAtomsNlocal",&nlocal);            // Pass a pointer to the number of atoms on this node
plumed_cmd(plumedmain,"setAtomsGatindex",gatindex);         // Pass an array containing the indices of all the atoms on this node (used for domain decomposition)
plumed_cmd(plumedmain,"setAtomsContiguous",&start);         // Number the atoms on this node from start to start+nlocal   (used for particle decomposition)
plumed_cmd(plumedmain,"getApiVersion",api);                 // Pass the api version that plumed is using (what does this mean)???
\endverbatim 

\section Notes Notes

Compiler options to use shared libraries on many architectures: 
http://www.fortran-2000.com/ArnaudRecipes/sharedlib.html


*/
